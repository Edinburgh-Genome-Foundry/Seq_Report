{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Seq Report Simple reporting on a set of sequences for documentation purposes. Install pip install git+https://github.com/Edinburgh-Genome-Foundry/Seq_Report.git Usage import seqreport seq_fasta = \"seq.fa\" seq_coll = seqreport . SeqCollection ( records = seqreport . read_fasta ( seq_fasta ), projectname = \"EGF24\" ) seqreport . write_pdf_report ( \"seq_report.pdf\" , seq_coll ) Alternatively, use a CSV file to specify parameters: seq_coll = seqreport . seqcollection_from_csv ( csv_file = \"tests/data/values.csv\" ) Header is ignored, but there must be a header. Entries must match the SeqCollection parameters ( example ). Versioning Seq Report uses the semantic versioning scheme. License = MIT Seq Report is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Seq Report was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh","title":"Home"},{"location":"#seq-report","text":"Simple reporting on a set of sequences for documentation purposes.","title":"Seq Report"},{"location":"#install","text":"pip install git+https://github.com/Edinburgh-Genome-Foundry/Seq_Report.git","title":"Install"},{"location":"#usage","text":"import seqreport seq_fasta = \"seq.fa\" seq_coll = seqreport . SeqCollection ( records = seqreport . read_fasta ( seq_fasta ), projectname = \"EGF24\" ) seqreport . write_pdf_report ( \"seq_report.pdf\" , seq_coll ) Alternatively, use a CSV file to specify parameters: seq_coll = seqreport . seqcollection_from_csv ( csv_file = \"tests/data/values.csv\" ) Header is ignored, but there must be a header. Entries must match the SeqCollection parameters ( example ).","title":"Usage"},{"location":"#versioning","text":"Seq Report uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Seq Report is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Seq Report was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh","title":"License = MIT"},{"location":"reference/seqreport/","text":"Module seqreport View Source from .SeqCollection import SeqCollection , read_fasta , seqcollection_from_csv from .reports import write_pdf_report Sub-modules seqreport.SeqCollection seqreport.reports seqreport.version","title":"Index"},{"location":"reference/seqreport/#module-seqreport","text":"View Source from .SeqCollection import SeqCollection , read_fasta , seqcollection_from_csv from .reports import write_pdf_report","title":"Module seqreport"},{"location":"reference/seqreport/#sub-modules","text":"seqreport.SeqCollection seqreport.reports seqreport.version","title":"Sub-modules"},{"location":"reference/seqreport/SeqCollection/","text":"Module seqreport.SeqCollection View Source import csv from Bio import SeqIO class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol to display in the report. **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). \"\"\" def __init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = \"\u00a3\" , projectname = \"\" , comments = \"\" , ): self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . calculate_values () def calculate_values ( self ): self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base def read_fasta ( fasta ): \"\"\"Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\"\" return list ( SeqIO . parse ( fasta , \"fasta\" )) def seqcollection_from_csv ( csv_file , records = None , param_dict = {}): \"\"\"Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see the docstring of `SeqCollection`. \"\"\" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items (): # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ]) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items (): setattr ( seq_coll , key , value ) seq_coll . calculate_values () return seq_coll Functions read_fasta def read_fasta ( fasta ) Read a FASTA sequence file into a list of records. Parameters fasta The FASTA filepath ( str ). View Source def read_fasta ( fasta ) : \" \"\" Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\" \" return list ( SeqIO . parse ( fasta , \"fasta\" )) seqcollection_from_csv def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in param_dict ) or a list of SeqRecords must be specified. For the parameter descriptions, see the docstring of SeqCollection . View Source def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) : \" \"\" Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see the docstring of `SeqCollection`. \"\" \" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items () : # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ] ) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items () : set attr ( seq_coll , key , value ) seq_coll . calculate_values () return seq_coll Classes SeqCollection class SeqCollection ( records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = '\u00a3' , projectname = '' , comments = '' ) Class to store basic properties of a collection of sequences. Parameters records A list of Biopython SeqRecords. cost_per_base Cost per nucleotide base. cost_per_seq Fix overhead cost for each sequence part (cloning, delivery costs etc). currency_symbol The currency symbol to display in the report. projectname The name of the project ( str ). comments Any comments to be included in the report ( str ). View Source class SeqCollection : \" \"\" Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol to display in the report. **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). \"\" \" def __init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = \"\u00a3\" , projectname = \"\" , comments = \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base Methods calculate_values def calculate_values ( self ) View Source def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base","title":"Seqcollection"},{"location":"reference/seqreport/SeqCollection/#module-seqreportseqcollection","text":"View Source import csv from Bio import SeqIO class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol to display in the report. **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). \"\"\" def __init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = \"\u00a3\" , projectname = \"\" , comments = \"\" , ): self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . calculate_values () def calculate_values ( self ): self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base def read_fasta ( fasta ): \"\"\"Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\"\" return list ( SeqIO . parse ( fasta , \"fasta\" )) def seqcollection_from_csv ( csv_file , records = None , param_dict = {}): \"\"\"Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see the docstring of `SeqCollection`. \"\"\" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items (): # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ]) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items (): setattr ( seq_coll , key , value ) seq_coll . calculate_values () return seq_coll","title":"Module seqreport.SeqCollection"},{"location":"reference/seqreport/SeqCollection/#functions","text":"","title":"Functions"},{"location":"reference/seqreport/SeqCollection/#read_fasta","text":"def read_fasta ( fasta ) Read a FASTA sequence file into a list of records. Parameters fasta The FASTA filepath ( str ). View Source def read_fasta ( fasta ) : \" \"\" Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\" \" return list ( SeqIO . parse ( fasta , \"fasta\" ))","title":"read_fasta"},{"location":"reference/seqreport/SeqCollection/#seqcollection_from_csv","text":"def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in param_dict ) or a list of SeqRecords must be specified. For the parameter descriptions, see the docstring of SeqCollection . View Source def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) : \" \"\" Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see the docstring of `SeqCollection`. \"\" \" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items () : # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ] ) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items () : set attr ( seq_coll , key , value ) seq_coll . calculate_values () return seq_coll","title":"seqcollection_from_csv"},{"location":"reference/seqreport/SeqCollection/#classes","text":"","title":"Classes"},{"location":"reference/seqreport/SeqCollection/#seqcollection","text":"class SeqCollection ( records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = '\u00a3' , projectname = '' , comments = '' ) Class to store basic properties of a collection of sequences. Parameters records A list of Biopython SeqRecords. cost_per_base Cost per nucleotide base. cost_per_seq Fix overhead cost for each sequence part (cloning, delivery costs etc). currency_symbol The currency symbol to display in the report. projectname The name of the project ( str ). comments Any comments to be included in the report ( str ). View Source class SeqCollection : \" \"\" Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol to display in the report. **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). \"\" \" def __init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = \"\u00a3\" , projectname = \"\" , comments = \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base","title":"SeqCollection"},{"location":"reference/seqreport/SeqCollection/#methods","text":"","title":"Methods"},{"location":"reference/seqreport/SeqCollection/#calculate_values","text":"def calculate_values ( self ) View Source def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base","title":"calculate_values"},{"location":"reference/seqreport/reports/","text":"Module seqreport.reports View Source from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) SEQCOLLECTION_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"seq_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s )\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , seqcollection ): \"\"\"Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\"\" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) Variables ASSETS_PATH SEQCOLLECTION_REPORT_TEMPLATE STYLESHEET THIS_PATH Functions end_pug_to_html def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s)\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) write_pdf_report def write_pdf_report ( target , seqcollection ) Write a sequence collection report with a PDF summary. Parameters target Path for PDF file. seqcollection SeqCollection instance. View Source def write_pdf_report ( target , seqcollection ) : \" \"\" Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\" \" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Reports"},{"location":"reference/seqreport/reports/#module-seqreportreports","text":"View Source from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) SEQCOLLECTION_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"seq_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s )\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , seqcollection ): \"\"\"Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\"\" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Module seqreport.reports"},{"location":"reference/seqreport/reports/#variables","text":"ASSETS_PATH SEQCOLLECTION_REPORT_TEMPLATE STYLESHEET THIS_PATH","title":"Variables"},{"location":"reference/seqreport/reports/#functions","text":"","title":"Functions"},{"location":"reference/seqreport/reports/#end_pug_to_html","text":"def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s)\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context )","title":"end_pug_to_html"},{"location":"reference/seqreport/reports/#write_pdf_report","text":"def write_pdf_report ( target , seqcollection ) Write a sequence collection report with a PDF summary. Parameters target Path for PDF file. seqcollection SeqCollection instance. View Source def write_pdf_report ( target , seqcollection ) : \" \"\" Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\" \" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"write_pdf_report"},{"location":"reference/seqreport/version/","text":"Module seqreport.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/seqreport/version/#module-seqreportversion","text":"View Source __version__ = \"0.1.0\"","title":"Module seqreport.version"}]}