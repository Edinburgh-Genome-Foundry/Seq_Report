{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Seq Report Simple reporting on a set of sequences for documentation purposes. Install pip install git+https://github.com/Edinburgh-Genome-Foundry/Seq_Report.git See also build.yml or PDF Reports Installation instructions. Usage import seqreport seq_fasta = \"seq.fa\" seq_coll = seqreport . SeqCollection ( records = seqreport . read_fasta ( seq_fasta ), projectname = \"EGF24\" ) seqreport . write_pdf_report ( \"seq_report.pdf\" , seq_coll ) Alternatively, use a CSV file to specify parameters: seq_coll = seqreport . seqcollection_from_csv ( csv_file = \"tests/data/values.csv\" ) Header is ignored, but there must be a header. Entries must match the SeqCollection parameters ( example ). Versioning Seq Report uses the semantic versioning scheme. License = MIT Seq Report is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Seq Report was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh","title":"Home"},{"location":"#seq-report","text":"Simple reporting on a set of sequences for documentation purposes.","title":"Seq Report"},{"location":"#install","text":"pip install git+https://github.com/Edinburgh-Genome-Foundry/Seq_Report.git See also build.yml or PDF Reports Installation instructions.","title":"Install"},{"location":"#usage","text":"import seqreport seq_fasta = \"seq.fa\" seq_coll = seqreport . SeqCollection ( records = seqreport . read_fasta ( seq_fasta ), projectname = \"EGF24\" ) seqreport . write_pdf_report ( \"seq_report.pdf\" , seq_coll ) Alternatively, use a CSV file to specify parameters: seq_coll = seqreport . seqcollection_from_csv ( csv_file = \"tests/data/values.csv\" ) Header is ignored, but there must be a header. Entries must match the SeqCollection parameters ( example ).","title":"Usage"},{"location":"#versioning","text":"Seq Report uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Seq Report is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Seq Report was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2024 Edinburgh Genome Foundry, University of Edinburgh","title":"License = MIT"},{"location":"reference/seqreport/","text":"Module seqreport View Source from .SeqCollection import SeqCollection , read_fasta , seqcollection_from_csv from .reports import write_pdf_report Sub-modules seqreport.SeqCollection seqreport.reports seqreport.version","title":"Index"},{"location":"reference/seqreport/#module-seqreport","text":"View Source from .SeqCollection import SeqCollection , read_fasta , seqcollection_from_csv from .reports import write_pdf_report","title":"Module seqreport"},{"location":"reference/seqreport/#sub-modules","text":"seqreport.SeqCollection seqreport.reports seqreport.version","title":"Sub-modules"},{"location":"reference/seqreport/SeqCollection/","text":"Module seqreport.SeqCollection View Source import csv import os from Bio import SeqIO class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol (or string) to display in the report (`str`). **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). **min_length** > Check that all sequences are at least this long (`int`). **max_length** > Check that all sequences are at most this long (`int`). **name_length** > Check which sequence IDs are longer than this cutoff. Genbank has a character limit (`int`). **assembly_plan** > Optional assembly plan CSV path for calculating savings by re-using DNA parts. **fasta_name** > Optional name of the fasta file for easy identification (`str`). \"\"\" def __ init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol= \"\u00a3\" , projectname= \"\" , comments= \"\" , min_length = 100 , # a good cutoff for min DNA synthesis length max_length = 3000 , # a good cutoff for max DNA synthesis length name_length = 15 , # max seq record name length . Genbank character limit . assembly_plan= \"\" , fasta_name= \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . min_length = min_length self . max_length = max_length self . name_length = name_length self . assembly_plan = assembly_plan self . fasta_name = fasta_name self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don't have any savings from the sequence. if count_in_plan < 1: # also find the ones not in the assembly plan self.not_in_plan += [record.id] self.total_cost_savings = ( self.total_savings * self.cost_per_base ) # ignore cost / seq self.total_cost_savings = round( self.total_cost_savings ) # (in)accuracy is fine for our purposes # For the PDF report: self.not_in_plan_text = \" ; \".join(self.not_in_plan) self.savings_dict_text = \" ; \".join( [f\"{key} (\u00d7{value})\" for key, value in self.savings_dict.items()] ) else: self.savings_dict_text = \"\" self.not_in_plan_text = \"\" def read_fasta(fasta): \"\"\"Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\"\" return list(SeqIO.parse(fasta, \"fasta\")) def seqcollection_from_csv(csv_file, records=None, param_dict={}): \"\"\"Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters . Either a FASTA file ( in the CSV or in ` param_dict ` ) or a list of ` SeqRecords ` must be specified . For the parameter descriptions , see parameters in the docstring of ` SeqCollection ` , except records and fasta_name . \"\"\" with open(csv_file, \" r \") as f: reader = csv.reader(f, skipinitialspace=True) next(reader) # ignore header parameters = {} for row in reader: if row[1] == \"\": # in case the full param list is in the csv continue else: parameters[row[0]] = row[1] for key, value in param_dict.items(): # override with function values parameters[key] = value if records: pass else: records = read_fasta(parameters[\" fasta \"]) seq_coll = SeqCollection(records=records) for key, value in parameters.items(): setattr(seq_coll, key, value) # To ensure that the correct filename is used: setattr(seq_coll, \" fasta_name \", os.path.basename(parameters[\" fasta \" ])) seq_coll . calculate_values () return seq_coll Functions read_fasta def read_fasta ( fasta ) Read a FASTA sequence file into a list of records. Parameters fasta The FASTA filepath ( str ). View Source def read_fasta ( fasta ) : \" \"\" Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\" \" return list ( SeqIO . parse ( fasta , \"fasta\" )) seqcollection_from_csv def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in param_dict ) or a list of SeqRecords must be specified. For the parameter descriptions, see parameters in the docstring of SeqCollection , except records and fasta_name. View Source def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) : \" \"\" Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see parameters in the docstring of `SeqCollection`, except records and fasta_name. \"\" \" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items () : # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ] ) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items () : set attr ( seq_coll , key , value ) # To ensure that the correct filename is used: set attr ( seq_coll , \"fasta_name\" , os . path . basename ( parameters [ \"fasta\" ] )) seq_coll . calculate_values () return seq_coll Classes SeqCollection class SeqCollection ( records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = '\u00a3' , projectname = '' , comments = '' , min_length = 100 , max_length = 3000 , name_length = 15 , assembly_plan = '' , fasta_name = '' ) Class to store basic properties of a collection of sequences. Parameters records A list of Biopython SeqRecords. cost_per_base Cost per nucleotide base. cost_per_seq Fix overhead cost for each sequence part (cloning, delivery costs etc). currency_symbol The currency symbol (or string) to display in the report ( str ). projectname The name of the project ( str ). comments Any comments to be included in the report ( str ). min_length Check that all sequences are at least this long ( int ). max_length Check that all sequences are at most this long ( int ). name_length Check which sequence IDs are longer than this cutoff. Genbank has a character limit ( int ). assembly_plan Optional assembly plan CSV path for calculating savings by re-using DNA parts. fasta_name Optional name of the fasta file for easy identification ( str ). View Source class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol (or string) to display in the report (`str`). **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). **min_length** > Check that all sequences are at least this long (`int`). **max_length** > Check that all sequences are at most this long (`int`). **name_length** > Check which sequence IDs are longer than this cutoff. Genbank has a character limit (`int`). **assembly_plan** > Optional assembly plan CSV path for calculating savings by re-using DNA parts. **fasta_name** > Optional name of the fasta file for easy identification (`str`). \"\"\" def __ init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol= \"\u00a3\" , projectname= \"\" , comments= \"\" , min_length = 100 , # a good cutoff for min DNA synthesis length max_length = 3000 , # a good cutoff for max DNA synthesis length name_length = 15 , # max seq record name length . Genbank character limit . assembly_plan= \"\" , fasta_name= \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . min_length = min_length self . max_length = max_length self . name_length = name_length self . assembly_plan = assembly_plan self . fasta_name = fasta_name self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don ' t have any savings from the sequence . if count_in_plan < 1 : # also find the ones not in the assembly plan self . not_in_plan += [ record . id ] self . total_cost_savings = ( self . total_savings * self . cost_per_base ) # ignore cost / seq self . total_cost_savings = round ( self . total_cost_savings ) # ( in ) accuracy is fine for our purposes # For the PDF report : self . not_in_plan_text = \" ; \" . join ( self . not_in_plan ) self . savings_dict_text = \" ; \" . join ( [ f \"{key} (\u00d7{value})\" for key , val ue in self . savings_dict . items ()] ) else : self . savings_dict_text = \"\" self . not_in_plan_text = \"\" Methods calculate_values def calculate_values ( self ) View Source def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don ' t have any savings from the sequence . if count_in_plan < 1 : # also find the ones not in the assembly plan self . not_in_plan += [ record . id ] self . total_cost_savings = ( self . total_savings * self . cost_per_base ) # ignore cost / seq self . total_cost_savings = round ( self . total_cost_savings ) # ( in ) accuracy is fine for our purposes # For the PDF report : self . not_in_plan_text = \" ; \" . join ( self . not_in_plan ) self . savings_dict_text = \" ; \" . join ( [ f \"{key} (\u00d7{value})\" for key , val ue in self . savings_dict . items ()] ) else : self . savings_dict_text = \"\" self . not_in_plan_text = \"\"","title":"Seqcollection"},{"location":"reference/seqreport/SeqCollection/#module-seqreportseqcollection","text":"View Source import csv import os from Bio import SeqIO class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol (or string) to display in the report (`str`). **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). **min_length** > Check that all sequences are at least this long (`int`). **max_length** > Check that all sequences are at most this long (`int`). **name_length** > Check which sequence IDs are longer than this cutoff. Genbank has a character limit (`int`). **assembly_plan** > Optional assembly plan CSV path for calculating savings by re-using DNA parts. **fasta_name** > Optional name of the fasta file for easy identification (`str`). \"\"\" def __ init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol= \"\u00a3\" , projectname= \"\" , comments= \"\" , min_length = 100 , # a good cutoff for min DNA synthesis length max_length = 3000 , # a good cutoff for max DNA synthesis length name_length = 15 , # max seq record name length . Genbank character limit . assembly_plan= \"\" , fasta_name= \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . min_length = min_length self . max_length = max_length self . name_length = name_length self . assembly_plan = assembly_plan self . fasta_name = fasta_name self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don't have any savings from the sequence. if count_in_plan < 1: # also find the ones not in the assembly plan self.not_in_plan += [record.id] self.total_cost_savings = ( self.total_savings * self.cost_per_base ) # ignore cost / seq self.total_cost_savings = round( self.total_cost_savings ) # (in)accuracy is fine for our purposes # For the PDF report: self.not_in_plan_text = \" ; \".join(self.not_in_plan) self.savings_dict_text = \" ; \".join( [f\"{key} (\u00d7{value})\" for key, value in self.savings_dict.items()] ) else: self.savings_dict_text = \"\" self.not_in_plan_text = \"\" def read_fasta(fasta): \"\"\"Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\"\" return list(SeqIO.parse(fasta, \"fasta\")) def seqcollection_from_csv(csv_file, records=None, param_dict={}): \"\"\"Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters . Either a FASTA file ( in the CSV or in ` param_dict ` ) or a list of ` SeqRecords ` must be specified . For the parameter descriptions , see parameters in the docstring of ` SeqCollection ` , except records and fasta_name . \"\"\" with open(csv_file, \" r \") as f: reader = csv.reader(f, skipinitialspace=True) next(reader) # ignore header parameters = {} for row in reader: if row[1] == \"\": # in case the full param list is in the csv continue else: parameters[row[0]] = row[1] for key, value in param_dict.items(): # override with function values parameters[key] = value if records: pass else: records = read_fasta(parameters[\" fasta \"]) seq_coll = SeqCollection(records=records) for key, value in parameters.items(): setattr(seq_coll, key, value) # To ensure that the correct filename is used: setattr(seq_coll, \" fasta_name \", os.path.basename(parameters[\" fasta \" ])) seq_coll . calculate_values () return seq_coll","title":"Module seqreport.SeqCollection"},{"location":"reference/seqreport/SeqCollection/#functions","text":"","title":"Functions"},{"location":"reference/seqreport/SeqCollection/#read_fasta","text":"def read_fasta ( fasta ) Read a FASTA sequence file into a list of records. Parameters fasta The FASTA filepath ( str ). View Source def read_fasta ( fasta ) : \" \"\" Read a FASTA sequence file into a list of records. **Parameters** **fasta** > The FASTA filepath (`str`). \"\" \" return list ( SeqIO . parse ( fasta , \"fasta\" ))","title":"read_fasta"},{"location":"reference/seqreport/SeqCollection/#seqcollection_from_csv","text":"def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in param_dict ) or a list of SeqRecords must be specified. For the parameter descriptions, see parameters in the docstring of SeqCollection , except records and fasta_name. View Source def seqcollection_from_csv ( csv_file , records = None , param_dict = {} ) : \" \"\" Create a SeqCollection, using parameters in a CSV file. The CSV file parameters override the default class parameters, and this function's parameters override the CSV file parameters. Either a FASTA file (in the CSV or in `param_dict`) or a list of `SeqRecords` must be specified. For the parameter descriptions, see parameters in the docstring of `SeqCollection`, except records and fasta_name. \"\" \" with open ( csv_file , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header parameters = {} for row in reader : if row [ 1 ] == \"\" : # in case the full param list is in the csv continue else : parameters [ row [ 0 ]] = row [ 1 ] for key , value in param_dict . items () : # override with function values parameters [ key ] = value if records : pass else : records = read_fasta ( parameters [ \"fasta\" ] ) seq_coll = SeqCollection ( records = records ) for key , value in parameters . items () : set attr ( seq_coll , key , value ) # To ensure that the correct filename is used: set attr ( seq_coll , \"fasta_name\" , os . path . basename ( parameters [ \"fasta\" ] )) seq_coll . calculate_values () return seq_coll","title":"seqcollection_from_csv"},{"location":"reference/seqreport/SeqCollection/#classes","text":"","title":"Classes"},{"location":"reference/seqreport/SeqCollection/#seqcollection","text":"class SeqCollection ( records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol = '\u00a3' , projectname = '' , comments = '' , min_length = 100 , max_length = 3000 , name_length = 15 , assembly_plan = '' , fasta_name = '' ) Class to store basic properties of a collection of sequences. Parameters records A list of Biopython SeqRecords. cost_per_base Cost per nucleotide base. cost_per_seq Fix overhead cost for each sequence part (cloning, delivery costs etc). currency_symbol The currency symbol (or string) to display in the report ( str ). projectname The name of the project ( str ). comments Any comments to be included in the report ( str ). min_length Check that all sequences are at least this long ( int ). max_length Check that all sequences are at most this long ( int ). name_length Check which sequence IDs are longer than this cutoff. Genbank has a character limit ( int ). assembly_plan Optional assembly plan CSV path for calculating savings by re-using DNA parts. fasta_name Optional name of the fasta file for easy identification ( str ). View Source class SeqCollection : \"\"\"Class to store basic properties of a collection of sequences. **Parameters** **records** > A list of Biopython SeqRecords. **cost_per_base** > Cost per nucleotide base. **cost_per_seq** > Fix overhead cost for each sequence part (cloning, delivery costs etc). **currency_symbol** > The currency symbol (or string) to display in the report (`str`). **projectname** > The name of the project (`str`). **comments** > Any comments to be included in the report (`str`). **min_length** > Check that all sequences are at least this long (`int`). **max_length** > Check that all sequences are at most this long (`int`). **name_length** > Check which sequence IDs are longer than this cutoff. Genbank has a character limit (`int`). **assembly_plan** > Optional assembly plan CSV path for calculating savings by re-using DNA parts. **fasta_name** > Optional name of the fasta file for easy identification (`str`). \"\"\" def __ init__ ( self , records , cost_per_base = 0.25 , cost_per_seq = 0 , currency_symbol= \"\u00a3\" , projectname= \"\" , comments= \"\" , min_length = 100 , # a good cutoff for min DNA synthesis length max_length = 3000 , # a good cutoff for max DNA synthesis length name_length = 15 , # max seq record name length . Genbank character limit . assembly_plan= \"\" , fasta_name= \"\" , ) : self . sequences = records self . cost_per_base = cost_per_base self . cost_per_seq = cost_per_seq self . currency_symbol = currency_symbol self . projectname = projectname self . comments = comments self . min_length = min_length self . max_length = max_length self . name_length = name_length self . assembly_plan = assembly_plan self . fasta_name = fasta_name self . calculate_values () def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don ' t have any savings from the sequence . if count_in_plan < 1 : # also find the ones not in the assembly plan self . not_in_plan += [ record . id ] self . total_cost_savings = ( self . total_savings * self . cost_per_base ) # ignore cost / seq self . total_cost_savings = round ( self . total_cost_savings ) # ( in ) accuracy is fine for our purposes # For the PDF report : self . not_in_plan_text = \" ; \" . join ( self . not_in_plan ) self . savings_dict_text = \" ; \" . join ( [ f \"{key} (\u00d7{value})\" for key , val ue in self . savings_dict . items ()] ) else : self . savings_dict_text = \"\" self . not_in_plan_text = \"\"","title":"SeqCollection"},{"location":"reference/seqreport/SeqCollection/#methods","text":"","title":"Methods"},{"location":"reference/seqreport/SeqCollection/#calculate_values","text":"def calculate_values ( self ) View Source def calculate_values ( self ) : self . cost_per_base = float ( self . cost_per_base ) # could be str after update self . cost_per_seq = float ( self . cost_per_seq ) self . n_seq = len ( self . sequences ) # Numbers section n_bp = 0 for part in self . sequences : n_bp += len ( part . seq ) self . n_bp = n_bp self . cost = self . n_seq * self . cost_per_seq + self . n_bp * self . cost_per_base self . cost = round ( self . cost ) # ( in ) accuracy is fine for our purposes # Lengths section self . too_short = [] self . too_long = [] self . long_names = [] for record in self . sequences : if len ( record ) < self . min_length : self . too_short += [ record . id ] if len ( record ) > self . max_length : self . too_long += [ record . id ] if len ( record . id ) > self . name_length : self . long_names += [ record . id ] self . too_short = list ( set ( self . too_short )) self . too_long = list ( set ( self . too_long )) self . long_names = list ( set ( self . long_names )) # Repeats will be checked further below . # For the PDF report : self . too_short_text = \" ; \" . join ( self . too_short ) self . too_long_text = \" ; \" . join ( self . too_long ) self . long_names_text = \" ; \" . join ( self . long_names ) # Repeats section self . repeat_names = [] self . repeat_seq = [] self . reverse_complement_seq = [] for index , record in enumerate ( self . sequences [ :- 1 ]) : for other_record in self . sequences [ index + 1 : ] : if record . id == other_record . id : self . repeat_names += [ record . id ] if record . seq == other_record . seq : self . repeat_seq += [( record . id , other_record . id )] if record . seq == other_record . seq . reverse_complement () : self . reverse_complement_seq += [( record . id , other_record . id )] self . repeat_names = list ( set ( self . repeat_names )) # For the PDF report : self . repeat_names_text = \" ; \" . join ( self . repeat_names ) repeat_seq_text_list = [] for identifier in self . repeat_seq : combined = \" = \" . join ( identifier ) repeat_seq_text_list += [ combined ] self . repeat_seq_text = \" ; \" . join ( repeat_seq_text_list ) reverse_complement_seq_text_list = [] for identifier in self . reverse_complement_seq : combined = \" = \" . join ( identifier ) reverse_complement_seq_text_list += [ combined ] self . reverse_complement_seq_text = \" ; \" . join ( reverse_complement_seq_text_list ) # Savings section if self . assembly_plan : self . not_in_plan = [] all_rows = [] with open ( self . assembly_plan , \"r\" ) as f : reader = csv . reader ( f , skipinitialspace = True ) next ( reader ) # ignore header for row in reader : all_rows += row [ 1 : ] # first column is construct name self . savings_dict = {} self . total_savings = 0 for record in self . sequences : count_in_plan = all_rows . count ( record . id ) if count_in_plan > 1 : # we count re - use savings only self . total_savings += len ( record . seq ) * ( count_in_plan - 1 ) # ignore first synthesis self . savings_dict [ record . id ] = count_in_plan # else we don ' t have any savings from the sequence . if count_in_plan < 1 : # also find the ones not in the assembly plan self . not_in_plan += [ record . id ] self . total_cost_savings = ( self . total_savings * self . cost_per_base ) # ignore cost / seq self . total_cost_savings = round ( self . total_cost_savings ) # ( in ) accuracy is fine for our purposes # For the PDF report : self . not_in_plan_text = \" ; \" . join ( self . not_in_plan ) self . savings_dict_text = \" ; \" . join ( [ f \"{key} (\u00d7{value})\" for key , val ue in self . savings_dict . items ()] ) else : self . savings_dict_text = \"\" self . not_in_plan_text = \"\"","title":"calculate_values"},{"location":"reference/seqreport/reports/","text":"Module seqreport.reports View Source from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) SEQCOLLECTION_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"seq_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s )\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , seqcollection ): \"\"\"Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\"\" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) Variables ASSETS_PATH SEQCOLLECTION_REPORT_TEMPLATE STYLESHEET THIS_PATH Functions end_pug_to_html def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s)\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) write_pdf_report def write_pdf_report ( target , seqcollection ) Write a sequence collection report with a PDF summary. Parameters target Path for PDF file. seqcollection SeqCollection instance. View Source def write_pdf_report ( target , seqcollection ) : \" \"\" Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\" \" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Reports"},{"location":"reference/seqreport/reports/#module-seqreportreports","text":"View Source from datetime import datetime import os from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) SEQCOLLECTION_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"seq_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s )\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , seqcollection ): \"\"\"Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\"\" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Module seqreport.reports"},{"location":"reference/seqreport/reports/#variables","text":"ASSETS_PATH SEQCOLLECTION_REPORT_TEMPLATE STYLESHEET THIS_PATH","title":"Variables"},{"location":"reference/seqreport/reports/#functions","text":"","title":"Functions"},{"location":"reference/seqreport/reports/#end_pug_to_html","text":"def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by Seq Report (version %s)\" % ( now , __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context )","title":"end_pug_to_html"},{"location":"reference/seqreport/reports/#write_pdf_report","text":"def write_pdf_report ( target , seqcollection ) Write a sequence collection report with a PDF summary. Parameters target Path for PDF file. seqcollection SeqCollection instance. View Source def write_pdf_report ( target , seqcollection ) : \" \"\" Write a sequence collection report with a PDF summary. **Parameters** **target** > Path for PDF file. **seqcollection** > `SeqCollection` instance. \"\" \" html = end_pug_to_html ( SEQCOLLECTION_REPORT_TEMPLATE , seqcollection = seqcollection ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"write_pdf_report"},{"location":"reference/seqreport/version/","text":"Module seqreport.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/seqreport/version/#module-seqreportversion","text":"View Source __version__ = \"0.1.0\"","title":"Module seqreport.version"}]}